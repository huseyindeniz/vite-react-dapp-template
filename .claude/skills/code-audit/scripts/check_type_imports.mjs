#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get project root (4 levels up from script location)
const projectRoot = path.resolve(__dirname, '../../../..');
const srcDir = path.join(projectRoot, 'src');

// Valid file extensions to scan (TypeScript files)
const validExtensions = ['.ts', '.tsx'];

/**
 * Normalize path for consistent comparison (forward slashes)
 */
function normalizePath(p) {
  return p.replace(/\\/g, '/');
}

/**
 * Check if a file should be excluded from type import checks
 */
function shouldExcludeFile(filePath) {
  const basename = path.basename(filePath);
  const normalizedPath = normalizePath(path.relative(projectRoot, filePath));

  // Exclude test files
  if (basename.includes('.test.') || basename.includes('.spec.')) {
    return true;
  }

  // Exclude type definition files
  if (basename.endsWith('.d.ts')) {
    return true;
  }

  // Exclude Storybook files
  if (basename.includes('.stories.')) {
    return true;
  }

  // Exclude test-utils directory
  if (normalizedPath.startsWith('src/test-utils/')) {
    return true;
  }

  // Exclude autogenerated files
  if (normalizedPath.includes('/types/common.ts')) {
    return true;
  }

  return false;
}

/**
 * Find type keyword usage in import statements
 */
function findTypeImports(content) {
  const lines = content.split('\n');
  const typeImports = [];

  // Patterns to detect type keyword in imports
  const typeImportPatterns = [
    // import type { X } from './somewhere'
    { pattern: /^import\s+type\s+\{/, description: 'Type-only import' },
    // import { type X } from './somewhere'
    { pattern: /^import\s+\{[^}]*\btype\s+\w+/, description: 'Inline type import' },
    // import { X, type Y } from './somewhere' (mixed)
    { pattern: /^import\s+\{[^}]*,\s*type\s+\w+/, description: 'Mixed type/value import' },
  ];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip comments
    if (line.startsWith('//') || line.startsWith('*') || line.startsWith('/*')) {
      continue;
    }

    for (const { pattern, description } of typeImportPatterns) {
      if (pattern.test(line)) {
        typeImports.push({
          line: i + 1,
          content: line,
          description,
        });
        break; // Only match first pattern per line
      }
    }
  }

  return typeImports;
}

/**
 * Get all TypeScript files in a directory recursively
 */
function getTypeScriptFiles(dir) {
  let results = [];

  try {
    const list = fs.readdirSync(dir);

    for (const file of list) {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);

      if (stat.isDirectory()) {
        // Skip node_modules
        if (file === 'node_modules') {
          continue;
        }
        results = results.concat(getTypeScriptFiles(filePath));
      } else {
        const ext = path.extname(file);
        if (validExtensions.includes(ext)) {
          results.push(filePath);
        }
      }
    }
  } catch (error) {
    // Directory doesn't exist or can't be read
  }

  return results;
}

/**
 * Main check function
 */
function checkTypeImports() {
  console.log('Type Import Check (No "type" Keyword in Imports)');
  console.log('='.repeat(80));
  console.log('');

  const files = getTypeScriptFiles(srcDir);
  console.log(`Scanning ${files.length} TypeScript files in src/...`);
  console.log('');

  const violations = [];

  for (const file of files) {
    if (shouldExcludeFile(file)) {
      continue;
    }

    const content = fs.readFileSync(file, 'utf-8');
    const typeImports = findTypeImports(content);

    if (typeImports.length > 0) {
      violations.push({
        file,
        typeImports,
      });
    }
  }

  if (violations.length === 0) {
    console.log('✅ No type import violations found! All imports are plain.\n');
    console.log('='.repeat(80));
    console.log('Summary');
    console.log('='.repeat(80));
    console.log('');
    console.log('Files with type imports: 0');
    console.log('Total type import statements: 0');
    console.log('');
    console.log('✅ All type import checks passed!');
    return true;
  }

  console.log('Type Import Violations');
  console.log('-'.repeat(80));
  console.log('');
  console.log(`❌ Found ${violations.length} file(s) with "type" keyword in imports\n`);

  let totalTypeImports = 0;

  for (const { file, typeImports } of violations) {
    const relativePath = normalizePath(path.relative(projectRoot, file));
    console.log(`  ❌ ${relativePath} (${typeImports.length} type import(s))`);

    for (const { line, content, description } of typeImports) {
      console.log(`     Line ${line}: ${content}`);
      console.log(`     Type: ${description}`);
      totalTypeImports++;
    }

    console.log(`     Rule: No "type" keyword in import statements`);
    console.log(`     Why: TypeScript can infer type-only imports automatically`);
    console.log(`     Fix: Remove "type" keyword from import statement`);
    console.log('');
  }

  console.log('='.repeat(80));
  console.log('Summary');
  console.log('='.repeat(80));
  console.log('');
  console.log(`Files with type imports: ${violations.length}`);
  console.log(`Total type import statements: ${totalTypeImports}`);
  console.log('');
  console.log('❌ Type import violations found.');
  console.log('');
  console.log('Why this matters:');
  console.log('  - TypeScript automatically removes type-only imports during compilation');
  console.log('  - "type" keyword is redundant and adds visual noise');
  console.log('  - Simpler, cleaner import statements');
  console.log('  - Consistent import style across codebase');
  console.log('');
  console.log('The Rule:');
  console.log('  - ❌ import type { X } from "./somewhere"');
  console.log('  - ❌ import { type X } from "./somewhere"');
  console.log('  - ❌ import { X, type Y } from "./somewhere"');
  console.log('  - ✅ import { X, Y } from "./somewhere"');

  return false;
}

// Run the check
const passed = checkTypeImports();
process.exit(passed ? 0 : 1);
