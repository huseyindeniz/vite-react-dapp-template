#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get project root (4 levels up from script location)
const projectRoot = path.resolve(__dirname, '../../../..');
const srcDir = path.join(projectRoot, 'src');

// Valid file extensions to scan (TypeScript files)
const validExtensions = ['.ts', '.tsx'];

/**
 * Normalize path for consistent comparison (forward slashes)
 */
function normalizePath(p) {
  return p.replace(/\\/g, '/');
}

/**
 * Check if a file should be excluded from re-export checks
 */
function shouldExcludeFile(filePath) {
  const basename = path.basename(filePath);
  const normalizedPath = normalizePath(path.relative(projectRoot, filePath));

  // Exclude test files
  if (basename.includes('.test.') || basename.includes('.spec.')) {
    return true;
  }

  // Exclude type definition files
  if (basename.endsWith('.d.ts')) {
    return true;
  }

  // Exclude Storybook files
  if (basename.includes('.stories.')) {
    return true;
  }

  // Exclude test-utils directory
  if (normalizedPath.startsWith('src/test-utils/')) {
    return true;
  }

  // Exclude autogenerated files
  if (normalizedPath.includes('/types/common.ts')) {
    return true;
  }

  return false;
}

/**
 * Find re-export statements in content
 */
function findReexports(content) {
  const lines = content.split('\n');
  const reexports = [];

  // Patterns to detect re-exports
  const reexportPatterns = [
    // export { something } from './somewhere'
    { pattern: /^export\s+\{[^}]+\}\s+from\s+['"]/, description: 'Named re-export' },
    // export * from './somewhere'
    { pattern: /^export\s+\*\s+from\s+['"]/, description: 'Wildcard re-export' },
    // export * as something from './somewhere'
    { pattern: /^export\s+\*\s+as\s+\w+\s+from\s+['"]/, description: 'Namespace re-export' },
    // export type { something } from './somewhere'
    { pattern: /^export\s+type\s+\{[^}]+\}\s+from\s+['"]/, description: 'Type re-export' },
  ];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip comments
    if (line.startsWith('//') || line.startsWith('*') || line.startsWith('/*')) {
      continue;
    }

    for (const { pattern, description } of reexportPatterns) {
      if (pattern.test(line)) {
        reexports.push({
          line: i + 1,
          content: line,
          description,
        });
      }
    }
  }

  return reexports;
}

/**
 * Get all TypeScript files in a directory recursively
 */
function getTypeScriptFiles(dir) {
  let results = [];

  try {
    const list = fs.readdirSync(dir);

    for (const file of list) {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);

      if (stat.isDirectory()) {
        // Skip node_modules
        if (file === 'node_modules') {
          continue;
        }
        results = results.concat(getTypeScriptFiles(filePath));
      } else {
        const ext = path.extname(file);
        if (validExtensions.includes(ext)) {
          results.push(filePath);
        }
      }
    }
  } catch (error) {
    // Directory doesn't exist or can't be read
  }

  return results;
}

/**
 * Main check function
 */
function checkReexports() {
  console.log('Re-export Check (No Re-exports Rule)');
  console.log('='.repeat(80));
  console.log('');

  const files = getTypeScriptFiles(srcDir);
  console.log(`Scanning ${files.length} TypeScript files in src/...`);
  console.log('');

  const violations = [];

  for (const file of files) {
    if (shouldExcludeFile(file)) {
      continue;
    }

    const content = fs.readFileSync(file, 'utf-8');
    const reexports = findReexports(content);

    if (reexports.length > 0) {
      violations.push({
        file,
        reexports,
      });
    }
  }

  if (violations.length === 0) {
    console.log('✅ No re-export violations found! All imports are direct.\n');
    console.log('='.repeat(80));
    console.log('Summary');
    console.log('='.repeat(80));
    console.log('');
    console.log('Files with re-exports: 0');
    console.log('Total re-export statements: 0');
    console.log('');
    console.log('✅ All re-export checks passed!');
    return true;
  }

  console.log('Re-export Violations');
  console.log('-'.repeat(80));
  console.log('');
  console.log(`❌ Found ${violations.length} file(s) with re-export statements\n`);

  let totalReexports = 0;

  for (const { file, reexports } of violations) {
    const relativePath = normalizePath(path.relative(projectRoot, file));
    console.log(`  ❌ ${relativePath} (${reexports.length} re-export(s))`);

    for (const { line, content, description } of reexports) {
      console.log(`     Line ${line}: ${content}`);
      console.log(`     Type: ${description}`);
      totalReexports++;
    }

    console.log(`     Rule: No re-exports allowed`);
    console.log(`     Why: Import directly from source files instead of re-exporting`);
    console.log(`     Fix: Update imports to point to the actual source file`);
    console.log('');
  }

  console.log('='.repeat(80));
  console.log('Summary');
  console.log('='.repeat(80));
  console.log('');
  console.log(`Files with re-exports: ${violations.length}`);
  console.log(`Total re-export statements: ${totalReexports}`);
  console.log('');
  console.log('❌ Re-export violations found.');
  console.log('');
  console.log('Why this matters:');
  console.log('  - Re-exports create indirection and make code harder to navigate');
  console.log('  - Direct imports make dependencies explicit');
  console.log('  - Eliminates barrel files and index.ts anti-pattern');
  console.log('  - Makes refactoring easier (no need to update re-export files)');
  console.log('');
  console.log('The Rule:');
  console.log('  - Import directly from source files');
  console.log('  - No export { X } from "./somewhere"');
  console.log('  - No export * from "./somewhere"');

  return false;
}

// Run the check
const passed = checkReexports();
process.exit(passed ? 0 : 1);
