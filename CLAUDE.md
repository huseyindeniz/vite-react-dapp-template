# CLAUDE.md

This file provides guidance to Claude Code when working with this React dApp template. Follow these patterns strictly to maintain architectural consistency.

---

## üìã Code Quality Enforcement

‚ö†Ô∏è **AUTOMATED CHECKS**: Code quality and architecture rules are automatically enforced by skills:

### Code-Level Checks (`code-audit` skill):
- Import/export patterns (path aliases, no default exports, no index files)
- Redux abstraction (no direct useDispatch/useSelector in components)
- Service dependency injection (services only imported in composition root)
- i18n coverage (all UI text must use t() function)
- TypeScript type safety (no "any" type usage)
- No linter/TypeScript suppressions
- 1 entity per file (no god files)

**See `.claude/skills/code-audit/skill.md` for detailed rules and examples.**

### Architecture-Level Checks (`arch-audit` skill):
- Feature dependency rules (core features cannot depend on domain features)
- Cross-feature dependency analysis and visualization

**See `.claude/skills/arch-audit/skill.md` for architecture dependency rules.**

---

## ‚ö†Ô∏è CRITICAL ARCHITECTURE PATTERNS (NEVER VIOLATE)

### 1. Feature-Model Architecture Pattern

**RULE**: Each **domain feature** organizes code by models. Each model MUST have its own directory, even if there's only ONE model.

‚ö†Ô∏è **NOTE**: This rule applies ONLY to **domain features** (wallet, auth, blog-demo, and any new features users create). It does NOT apply to **core features** (app, i18n, router, slice-manager, ui) which are infrastructure with their own specialized structures.

#### Model Directory Structure

```
src/features/{feature}/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ {model}/              # Each model has own directory
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IModelApi.ts      # Interface for external dependencies
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actions.ts        # Redux action creators
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slice.ts          # Redux slice (state only)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actionEffects/    # Business logic (Redux Saga)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ *.ts          # Individual action effect files
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/            # TypeScript types
‚îÇ   ‚îî‚îÄ‚îÄ {model2}/             # Another model (if exists)
‚îú‚îÄ‚îÄ hooks/                    # Feature-specific hooks (CRITICAL)
‚îÇ   ‚îú‚îÄ‚îÄ useActions.ts         # Action dispatchers for components
‚îÇ   ‚îî‚îÄ‚îÄ use{Feature}.ts       # State access hooks (e.g., useWallet, useAuth)
‚îú‚îÄ‚îÄ hocs/                     # Higher Order Components (when applicable)
‚îú‚îÄ‚îÄ IFeatureApi.ts            # Root: Combined interface
‚îú‚îÄ‚îÄ slice.ts                  # Root: combineReducers from all models
‚îî‚îÄ‚îÄ sagas.ts                  # Root: Saga watchers
```

**Root Slice Pattern (REQUIRED):**

```typescript
// src/features/{feature}/slice.ts
import { combineReducers } from '@reduxjs/toolkit';
import { sessionReducer } from './models/session/slice';

export const authReducer = combineReducers({
  session: sessionReducer,
});
```

**State Access Pattern:**

```typescript
// ‚ö†Ô∏è State is nested by model: state.{feature}.{model}
// Components access state via feature hooks, NOT direct useSelector
// - Feature hooks (useWallet, useAuth): for feature's own state
// - useTypedSelector: for cross-feature state access
// Example state paths:
//   state.auth.session
//   state.wallet.provider
//   state.wallet.network
```

---

### 2. Business Logic Separation (MOST CRITICAL)

**RULE**: Business logic lives in EXACTLY ONE PLACE: `actionEffects/` (Redux Saga generators). NEVER put business logic anywhere else.

#### ‚úÖ Business Logic ONLY in actionEffects/

**What belongs in actionEffects:**

- State machine logic (HandleState\* functions)
- API calls (`yield call(api.method)`)
- Error handling and retry logic
- Complex async workflows
- Side effects (logging, analytics)
- Business rules and validation
- Conditional logic based on state
- ALL business logic goes here

#### ‚ùå Slices are PURE State Containers

**What belongs in slices:**

- Simple state updates ONLY: `state.field = action.payload`
- ‚ùå NO API calls
- ‚ùå NO async logic
- ‚ùå NO business rules
- ‚ùå NO calculations
- ‚ùå NO conditional logic

#### ‚ùå Components are PURE Presentation

**What belongs in components:**

- Render UI based on state
- Call feature hook actions: `walletActions.connectWallet()` (NOT dispatch directly)
- Use feature hooks for state: `useWallet()`, `useAuth()` (NOT useSelector directly)
- Use `useTypedSelector` for cross-feature state access
- Handle user interactions (click, input)
- ‚ùå NO business logic
- ‚ùå NO API calls
- ‚ùå NO state machines
- ‚ùå NO async workflows
- ‚ùå NO direct useDispatch() or useSelector()

#### Summary: Separation of Concerns

| Layer              | Location         | Responsibility            | Contains Logic?         |
| ------------------ | ---------------- | ------------------------- | ----------------------- |
| **Business Logic** | `actionEffects/` | HOW and WHY things happen | ‚úÖ YES - ALL logic here |
| **State**          | `slice.ts`       | WHAT the current state is | ‚ùå NO - just mutations  |
| **Presentation**   | Components       | WHAT to display           | ‚ùå NO - just render     |

---

### 3. Interface Architecture (Dependency Inversion Principle)

**RULE**: Features define interfaces for what they need. Services implement those interfaces. This achieves decoupling.

#### Pattern Structure

**Each model defines its own interface:**

- Location: `src/features/{feature}/models/{model}/IModelApi.ts`
- Contains: Method signatures the model needs from external services

**Root combines model interfaces:**

- Location: `src/features/{feature}/IFeatureApi.ts`
- Pattern: `export interface IFeatureApi extends IModel1Api, IModel2Api {}`

**Services implement the interfaces:**

- Location: `src/services/{service}/`
- Pattern: `class Service implements IFeatureApi { ... }`

**ActionEffects receive interfaces (Dependency Injection):**

- Pattern: `function* ActionEffect(api: IModelApi) { ... }`
- API could be any implementation (EthersV5, EthersV6, mock, etc.)
- ActionEffects don't know or care about concrete implementation

#### Why This Matters

```
Without Dependency Inversion (‚ùå WRONG):
Feature ‚Üí imports ‚Üí Service ‚Üí imports ‚Üí External Library
(tight coupling, hard to test, hard to swap)

With Dependency Inversion (‚úÖ CORRECT):
Feature ‚Üí defines ‚Üí Interface ‚Üê implements ‚Üê Service ‚Üí uses ‚Üí External Library
(loose coupling, easy to test, easy to swap)
```

**Benefits:**

- Features don't know about external libraries (ethers.js, axios, etc.)
- Easy to swap implementations (EthersV5 ‚Üí EthersV6)
- Easy to test (mock interfaces)
- Clear boundaries between layers

**Naming Convention:**

```
models/account/IAccountApi.ts   # NOT IWalletAccountApi
models/provider/IProviderApi.ts # NOT IWalletProviderApi
models/network/INetworkApi.ts   # NOT IWalletNetworkApi

IWalletApi.ts                   # Root combined interface
IBlogDemoApi.ts                 # Root combined interface
IAuthApi.ts                     # Root combined interface
```

---

### 4. Component-Hook Abstraction (CRITICAL)

**RULE**: React components NEVER use Redux/RTK directly. They ALWAYS use feature-specific hooks.

#### Abstraction Layers

**Components use Feature Hooks:**

- Each feature has `hooks/` directory with custom hooks
- `useActions` hook: provides all action dispatchers for the feature
- Custom state hooks: provide typed state access (e.g., `useWallet`, `useAuth`)
- Components call these hooks instead of RTK primitives

**Feature Hooks use Root Hooks:**

- Feature hooks internally use `useTypedSelector` from `src/hooks/`
- Provides type-safe state access
- Abstracts Redux implementation details from components

**State Access Patterns:**

- **Own feature state**: Use feature-specific hooks (`useWallet()`, `useAuth()`)
- **Cross-feature state**: Use root `useTypedSelector` from `src/hooks/`

**HOCs (Higher Order Components):**

- Some features provide HOCs when applicable
- Use for cross-cutting concerns (auth protection, route guards, etc.)

#### Why This Matters

**Abstraction Benefits:**

- Components don't know about Redux/RTK internals
- Easy to swap state management library
- Feature hooks can add memoization/logic
- Clear, type-safe API for components
- Centralized state access patterns

**Rules:**

- ‚ùå NEVER use `useDispatch()` directly in components
- ‚ùå NEVER use `useSelector()` directly in components
- ‚úÖ ALWAYS use feature hooks (`useWalletActions()`, `useAuth()`, etc.)
- ‚úÖ Use root `useTypedSelector` only for cross-feature state access
- ‚úÖ Each feature provides its own hooks in `hooks/` directory

---

## Feature Categories: Core vs Domain

This template contains two distinct types of features with different structural requirements.

### ‚ö†Ô∏è Core Features (Infrastructure - EXCEPTIONS to Model Rules)

These features are **foundational infrastructure** that all other features depend on. They do NOT follow the model-based architecture pattern and have their own specialized structures.

**Core Features:**

- `app/` - Application root, provider composition, lazy loading
- `i18n/` - Internationalization infrastructure (i18next setup)
- `router/` - Routing infrastructure and utilities (React Router)
- `slice-manager/` - Redux slice lifecycle management system
- `ui/` - Mantine theme configuration and design system components

**Key Points:**

- ‚ùå **Do NOT apply model architecture rules to these features**
- ‚ùå **Do NOT expect models/ directories in these features**
- ‚ùå **Do NOT try to "fix" their structure to match domain features**
- ‚ö†Ô∏è **Be EXTRA CAREFUL when modifying - they affect ALL features**
- ‚ö†Ô∏è **Changes to core features require extra scrutiny**
- ‚úÖ These are intentionally structured differently
- ‚úÖ They are fixed parts of the template
- ‚úÖ Each has its own specialized structure (no models/ directories)

### ‚úÖ Domain Features (Business Logic - MUST Follow Model Rules)

These features represent business domains and serve as **examples/guides** for users building their applications. They MUST follow the strict model-based architecture pattern.

**Domain Features (Examples in Template):**

- `wallet/` - Web3 wallet integration (3 models: provider, network, account)
- `auth/` - Authentication (1 model: session)
- `blog-demo/` - Blog demonstration (2 models: post, author)

**Key Points:**

- ‚úÖ **MUST follow model-based architecture** (Pattern #1)
- ‚úÖ **Business logic ONLY in actionEffects/** (Pattern #2)
- ‚úÖ **Features define interfaces, services implement** (Pattern #3)
- ‚úÖ **Components use feature hooks, not RTK directly** (Pattern #4)
- ‚ÑπÔ∏è Users may remove, modify, or replace these examples
- ‚ÑπÔ∏è Users will create their own domain features (e.g., products, orders, inventory, users)
- ‚ÑπÔ∏è **These are guides showing HOW to structure domain features correctly**

**Example Domain Feature Structure:**

```
wallet/
‚îú‚îÄ‚îÄ models/                          # ‚úÖ Required for domain features
‚îÇ   ‚îú‚îÄ‚îÄ provider/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IProviderApi.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actions.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actionEffects/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ network/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ INetworkApi.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actions.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actionEffects/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ account/
‚îÇ       ‚îú‚îÄ‚îÄ IAccountApi.ts
‚îÇ       ‚îú‚îÄ‚îÄ actions.ts
‚îÇ       ‚îú‚îÄ‚îÄ slice.ts
‚îÇ       ‚îú‚îÄ‚îÄ actionEffects/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ hooks/                           # ‚úÖ Feature-specific hooks
‚îÇ   ‚îú‚îÄ‚îÄ useWalletActions.ts          # Action dispatchers
‚îÇ   ‚îî‚îÄ‚îÄ useWallet.ts                 # State access
‚îú‚îÄ‚îÄ hocs/                            # Higher Order Components (if applicable)
‚îú‚îÄ‚îÄ components/                      # UI components
‚îú‚îÄ‚îÄ IWalletApi.ts                    # Root combined interface
‚îú‚îÄ‚îÄ slice.ts                         # combineReducers from models
‚îî‚îÄ‚îÄ sagas.ts                         # Saga watchers
```

‚úÖ **Notice**: Has `models/` directory with proper structure - REQUIRED for domain features!

### Structure Comparison

| Aspect            | Core Features                        | Domain Features                        |
| ----------------- | ------------------------------------ | -------------------------------------- |
| **Purpose**       | Infrastructure for template          | Business logic examples                |
| **Models/**       | ‚ùå Not required                      | ‚úÖ Required                            |
| **Structure**     | Specialized per feature              | Standardized model pattern             |
| **Modifiability** | ‚ö†Ô∏è Careful - affects everything      | ‚úÖ User customizable                   |
| **Examples**      | app, i18n, router, slice-manager, ui | wallet, auth, blog-demo                |
| **User Action**   | Keep or modify carefully             | Remove, modify, replace, or create new |

---

## Development Commands

**Verification (REQUIRED after any code changes):**

```bash
npm run lint    # Must pass with 0 warnings
npm run test    # All tests must pass
npm run build   # Must build successfully
```

**Development:**

```bash
npm run dev                # Start dev server
npm run extract            # Extracts texts from components to resource files.
npm run check-translations # Validate i18n completeness
```

**Storybook:**

```bash
npm run storybook          # Component documentation
```

---

## ‚ö†Ô∏è GENERAL RULES (NEVER VIOLATE)

### Architecture Rules

1. **Each model MUST have its own directory** under `models/`, even if there's only ONE model
   - ‚ö†Ô∏è **Applies to DOMAIN features only** (wallet, auth, blog-demo, and any new domain features)
   - ‚ö†Ô∏è **Does NOT apply to CORE features** (app, i18n, router, slice-manager, ui)
   - ‚úÖ `auth/models/session/` (domain feature, single model)
   - ‚ùå `auth/models/` (files directly in models/)

1a. **Core features are infrastructure - be EXTRA CAREFUL**

- ‚ö†Ô∏è **Changes to core features (app, i18n, router, slice-manager, ui) affect EVERYTHING**
- ‚ö†Ô∏è **Core features have their own structure - DO NOT try to apply model patterns**
- ‚ö†Ô∏è **When modifying core features, understand the impact on all domain features**
- ‚ÑπÔ∏è **When in doubt about modifying core features, ASK the user first**

2. **Business logic ONLY in `actionEffects/`** - NEVER in slices or components
   - ‚úÖ API calls, state machines, error handling ‚Üí `actionEffects/`
   - ‚ùå Business logic in components or slices

2a. **Components use feature hooks - NEVER use RTK directly**

- ‚ùå NEVER use `useDispatch()` or `useSelector()` in components
- ‚úÖ ALWAYS use feature hooks: `useWalletActions()`, `useAuth()`, etc.
- ‚úÖ Use root `useTypedSelector` from `src/hooks/` for cross-feature state
- ‚úÖ Each feature has `hooks/` directory with `useActions` and state hooks

3. **Features define interfaces, services implement them**
   - ‚úÖ Each model has `IModelApi.ts`
   - ‚úÖ Root has `IFeatureApi.ts` extending model interfaces
   - ‚úÖ Services implement feature interfaces

4. **Whenever any code changes:**
   - MUST run: `npm run lint` (0 warnings required)
   - MUST run: `npm run test` (all tests pass)
   - MUST run: `npm run build` (successful build)

### Code Quality Rules

5. **NEVER use `npm run lint --fix`** - Fix ESLint issues manually

6. **React Hook Dependencies** - NEVER add unnecessary dependencies:
   - ‚ùå DON'T add stable references that never change (e.g., `t` from useTranslation, `actions` from hooks)
   - ‚ùå DON'T add props/params recreated on every render with same content (e.g., `allRoutes`)
   - ‚úÖ DO add only values that should trigger re-computation (e.g., `location.pathname`, `i18n.resolvedLanguage`)
   - Each unnecessary dependency creates exponential re-render combinations!

7. **Always follow best practices**
   - Never lead to hacky dead ends
   - Check latest documentation before designing
   - Never reinvent the wheel - use battle-tested, trusted, widely-adopted solutions

---

## Quick Reference

### Tech Stack

- **Build**: Vite + TypeScript
- **UI**: React 19 + Mantine v7
- **State**: Redux Toolkit + Redux Saga
- **Routing**: React Router DOM v7
- **Web3**: Ethers.js v6
- **Testing**: Vitest + React Testing Library
- **i18n**: i18next

### Import Aliases

```typescript
@/features/*   // Feature modules
@/services/*   // Service implementations
@/pages/*      // Page components
@/hooks/*      // Custom hooks
@/store/*      // Redux store
@test-utils    // Testing utilities
```

### Feature Categories

**Core Features (Infrastructure - Fixed):**

- `app/` - Application bootstrap and provider composition
- `i18n/` - Internationalization (i18next)
- `router/` - Routing infrastructure (React Router)
- `slice-manager/` - Redux slice lifecycle management
- `ui/` - Mantine theme and design system

**Domain Features (Examples - User Customizable):**

- `wallet/` - Web3 wallet (Provider, Network, Account models)
- `auth/` - Authentication (Session model)
- `blog-demo/` - Blog demo (Post, Author models)

**Users will:**

- Keep core features unchanged (or modify very carefully)
- Remove/modify/replace domain features as needed
- Create new domain features following the model pattern (e.g., products, orders, inventory)

### Configuration Files

- `src/features/wallet/config.ts` - Wallet configuration
- `src/features/ui/mantine/theme.tsx` - Mantine theme
- `vite.config.ts` - Build configuration
- `vitest.config.ts` - Test configuration
